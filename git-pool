#!/bin/bash

if [ "$GIT_POOL_HOME" == "" ]; then
    GIT_POOL_HOME="$HOME/.gitpool"
fi

[[ ! -d "$GIT_POOL_HOME" ]] && mkdir -p "$GIT_POOL_HOME"


function die() {
    echo $@
    exit 128
}

function find_url_in_pool() {
    local url="$1"
    local name=$(find "$GIT_POOL_HOME" -type f -name config -exec grep -H "$url" {} \; | cut -d ':' -f 1)
    [[ "$name" == "" ]] && echo "" && return
    dirname $(dirname "$name")
}

function mirror_from_pool() {
    local git_dir="$1/.git"
    local new_workdir="$2"
    local branch="$3"

    # From git-new-workdir
    #
    # create the links to the original repo.  explicitly exclude index, HEAD and
    # logs/HEAD from the list since they are purely related to the current working
    # directory, and should not be shared.
    for x in config refs logs/refs objects info hooks packed-refs remotes rr-cache svn
    do
        mkdir -p "$new_workdir/.git"
        # create a containing directory if needed
        case $x in
        */*)
            mkdir -p "$new_workdir/.git/${x%/*}"
            ;;
        esac

        ln -s "$git_dir/$x" "$new_workdir/.git/$x"
    done

    cp "$git_dir/HEAD" "$new_workdir/.git/HEAD"
    cd "$wd"
    git checkout -f $branch
}

function clone() {
    local git_url="${@: -2:1}"
    local wd="${@: -1}"

    if [[ `find_url_in_pool "$git_url"` == "" ]]; then
        pushd $GIT_POOL_HOME > /dev/null && git clone ${@:1:$len} && popd > /dev/null || die ""
    fi
    [[ "$?" -eq 0 ]] && mirror_from_pool $(find_url_in_pool "$git_url") $wd
}

function mirror() {
    local repo="$1"
    local wd="$2"
    local branch="$3"
    [[ ! -d "$GIT_POOL_HOME/$1" ]] && die "Repository does not exist"
    [[ -d "$wd" ]] && die "Destination is not empty"
    mirror_from_pool "$GIT_POOL_HOME/$repo" "$wd" $branch
}

function path() {
    find_url_in_pool $@
}

function list() {
    ls -1 $GIT_POOL_HOME
}

function name() {
    basename `find_url_in_pool $@`
}

command="$1"
shift

eval "$command $@"

